# include  <iverilog/ivl_target.h>
# include "aiger.h"
# include <stdio.h>
# include <stdlib.h>
# include <string.h>

// Logging
# define LOG_LEVEL_DEBUG0
# ifdef  LOG_LEVEL_DEBUG0
# define DEBUG0(...)  printf("\e[1;32mIFV AIG TARGET DEBUG   \e[0m | \t" __VA_ARGS__)
# else
# define DEBUG0(...)
# endif
# define WARNING(...) printf("\e[1;33mIFV AIG TARGET WARNING \e[0m | \t" __VA_ARGS__)
# define ERROR(...)   printf("\e[1;31mIFV AIG TARGET ERROR   \e[0m | \t" __VA_ARGS__)
# define INFO(...)    printf("\e[1;34mIFV AIG TARGET INFO    \e[0m | \t" __VA_ARGS__)

# define IFV_AIGER_COMMENT "Auto-Generated by Icarus Formal Verification Target "\
                           "(https://github.com/rjones-ese/icarus-fv/)"

//Other useful macros
# define IVL_SIGNAL_IS_INPUT( sig ) ( IVL_SIP_INPUT == ivl_signal_port(sig) )
# define IVL_SIGNAL_IS_OUTPUT( sig ) ( IVL_SIP_OUTPUT == ivl_signal_port(sig) )


/* --  Method Declarations -- */
int process_scope(ivl_scope_t scope, void * cd);
static int show_process(ivl_process_t net, void * x);
int show_constants(ivl_design_t des);
static int process_statements(ivl_statement_t net, int level);
int process_nexus( ivl_nexus_t nexus );
int process_lpm( ivl_lpm_t lpm );
int process_logic( ivl_net_logic_t log );
int process_signal( ivl_signal_t sig );

// Global declarations
char file_path [40];
aiger * aiger_handle;
unsigned aiger_index = 0;

// Literal Lookup Table Declarations

// Literal type
typedef struct lit_s {
  unsigned index;
  ivl_signal_t signal;
} lit_t;

// Crude lookup table structure
struct lit_lut_s {
  lit_t * literals;
  lit_t * literal_head;
  unsigned literal_len;
  unsigned literal_max;
};

//Global table
struct lit_lut_s lit_lut;

//Lookup table methods
int          lit_init     ( void );
void         lit_free     ( void );
unsigned     lit_add      ( const char * name );
unsigned     lit_get_index( const char * name );
const char * lit_get_name ( unsigned idx );
void         lit_iterate  ( void (* lit_iterate_cb ) ( unsigned idx, ivl_signal_t * sig ));

#define MAX_LIT 100

int lit_init ( void ){
  lit_lut.literals = malloc( MAX_LIT * sizeof(lit_t));
  lit_lut.literal_head = lit_lut.literals;
  lit_lut.literal_max = MAX_LIT;
  return 0;
}

void lit_free ( void ){
  free(lit_lut.literals);
}

unsigned lit_add ( const char * name ){
  if ( lit_lut.literal_len < lit_lut.literal_max ){
    return lit_lut.literal_len++;
  }
  return 0;
}


/******************************************************
 *      Method targetted by Icarus Verilog            *
 *****************************************************/
int target_design(ivl_design_t des)
{
  int ret_val;

  //Open File For Writing
  strcpy(file_path, ivl_design_flag(des, "-o"));
  INFO("File \"%s\" targetted for output \n",file_path);

  //Initialize Aiger Library
  aiger_handle = aiger_init();

  //Init Lookup Table
  lit_init();

  //Obtain Scopes from Design
  int num_scopes;
  ivl_scope_t  ** scopes, ** _scopes;
  scopes = malloc(sizeof(ivl_scope_t *));
  _scopes = scopes;
  ivl_design_roots(des,scopes,&num_scopes);

  DEBUG0("Processing %d scope%c\n",num_scopes,(num_scopes==1)?' ':'s');
  int idx = 0;
  while (idx < num_scopes){
    ret_val = process_scope(**scopes++,0);
    idx++;
  }

  // Parse Design Processes
  ivl_design_process(des,show_process,0);

  show_constants(des);

  //Write file
  aiger_add_comment(aiger_handle,IFV_AIGER_COMMENT);
  INFO("Writing to file %s\n",file_path);
  if ( !aiger_open_and_write_to_file(aiger_handle, file_path) ){
    ERROR("Unable to write to file\n");
    ret_val = -1;
  }else{
    DEBUG0("Successfully wrote to file\n");
  }

  //Free Aiger Lib
  aiger_free(aiger_handle);

  //Free Scope
  free(_scopes);

  //Free Lookup Table
  lit_free();

  return ret_val;
}

int process_scope(ivl_scope_t scope,void * cd){
  INFO("Scope name: %s\n",ivl_scope_name(scope));

  //Iterate through signals to find output ports
  DEBUG0("Determining output pins within scope\n");
  int idx;

  for ( idx = 0; idx < ivl_scope_sigs(scope); idx++ ) {
    ivl_nexus_t nexus;
    ivl_signal_t sig = ivl_scope_sig(scope,idx);
    if ( IVL_SIGNAL_IS_OUTPUT( sig ) ){
        INFO("Output signal (%s)\n",ivl_signal_name(sig));
        nexus = ivl_signal_nex(sig,0);
        process_nexus(nexus);
    }
  }
  ivl_scope_children(scope,process_scope,0);

  return 0;
}

unsigned nexus_counter = 0;
int process_nexus( ivl_nexus_t nexus ){

  if ( ivl_nexus_get_private( nexus ) ){
    //DEBUG0("Nexus already processed (%s)\n",ivl_nexus_name(nexus));
    return 0;
  }
  DEBUG0("Nexus level %d\n",nexus_counter++);
  //DEBUG0("Processing Nexus (%s)\n", ivl_nexus_name(nexus));
  ivl_nexus_set_private( nexus,(void * ) 1);

  int idx, ptrs;
  ivl_nexus_ptr_t nexus_ptr;
  ivl_signal_t nex_signal;
  ivl_net_logic_t nex_logic;
  ivl_switch_t nex_switch;
  ivl_branch_t nex_branch;
  ivl_lpm_t nex_lpm;

  ptrs = ivl_nexus_ptrs(nexus);
  DEBUG0("Num Nexus of Pointers %d\n",ptrs);

  for ( idx = 0; idx < ptrs; idx++ ){
    nexus_ptr = ivl_nexus_ptr(nexus,idx);

    nex_switch = ivl_nexus_ptr_switch(nexus_ptr);
    nex_branch = ivl_nexus_ptr_branch(nexus_ptr);
    nex_lpm    = ivl_nexus_ptr_lpm(nexus_ptr);

    DEBUG0("(%d) Ptr %d %d\n",
    nexus_counter,
    ivl_nexus_ptr_pin( nexus_ptr ),
    ivl_nexus_ptr_con( nexus_ptr )
    );

    if( 0 != nex_switch )
      DEBUG0("Ptr Switch %s\n",ivl_switch_basename(nex_switch));
    else if( 0 != nex_branch )
      DEBUG0("Ptr Branch\n");

    //process_pointer
    //if ( 0 != ivl_nexu

    process_signal( ivl_nexus_ptr_sig (nexus_ptr) );
    process_logic ( ivl_nexus_ptr_log (nexus_ptr) );
    process_lpm   ( ivl_nexus_ptr_lpm (nexus_ptr) );

  }
  int num_nexus_ptrs = ivl_nexus_ptrs(nexus);
  //DEBUG0("Nexus PTRS %d\n",num_nexus_ptrs);

  return 0;
}

int process_lpm( ivl_lpm_t lpm ){
  if ( 0 == lpm )
    return 0;

  DEBUG0("lpm %d\n", ivl_lpm_type( lpm ) );
  /*
  switch ( ivl_lpm_type( lpm ) ){

    case IVL_LPM_
  }
  */
  return 0;
}
int process_logic( ivl_net_logic_t log ){
  int idx;
  if ( 0 == log )
    return 0;

  switch ( ivl_logic_type(log)){

    // Implemented logical functions
    case IVL_LO_BUFIF0 :
    case IVL_LO_BUFIF1 :
    case IVL_LO_BUFZ   :
      DEBUG0("Buffer (%d)  %s \n", ivl_logic_width(log), ivl_logic_basename(log));
      break;
    case IVL_LO_NOT    :
      DEBUG0("Not element\n");
      break;
    case IVL_LO_AND    :
      DEBUG0("And element\n");
      break;
    case IVL_LO_OR     :
      DEBUG0("Or element\n");
      break;

    // Unimplemented logical functions
    case IVL_LO_NONE   :
    case IVL_LO_BUF    :
    case IVL_LO_CMOS   :
    case IVL_LO_NAND   :
    case IVL_LO_NMOS   :
    case IVL_LO_NOR    :
    case IVL_LO_NOTIF0 :
    case IVL_LO_NOTIF1 :
    case IVL_LO_PULLDOWN:
    case IVL_LO_PULLUP :
    case IVL_LO_RCMOS  :
    case IVL_LO_RNMOS  :
    case IVL_LO_RPMOS  :
    case IVL_LO_PMOS   :
    case IVL_LO_XNOR   :
    case IVL_LO_XOR    :
    default:
      WARNING("Unsupported logic element:\t%s\n",ivl_logic_basename(log));
  }
  for ( idx = 0; idx < ivl_logic_pins(log); idx++ ){
    DEBUG0("(%d) pin %d\n",nexus_counter,idx);
    process_nexus(ivl_logic_pin(log,idx));
  }
  return 0;
}

int process_signal( ivl_signal_t sig ){
  if ( 0 == sig )
    return 0;

  DEBUG0("Processing signal %s (level %d)\n",ivl_signal_basename(sig),nexus_counter);
  if ( IVL_SIGNAL_IS_INPUT( sig ) ){
      INFO("Input signal (%s)\n",ivl_signal_name(sig));
      return 0;
  }

  int idx;

  process_nexus(ivl_signal_nex(sig,0));
  return 0;
}
static int show_process(ivl_process_t net, void * x){

  process_statements(ivl_process_stmt(net),0);

  //ivl_scope_t scope = ivl_process_scope(net);
  //process_scope(&scope);

  return 0;
}

static int process_statements(ivl_statement_t net,int level){
  switch(ivl_statement_type(net)) {
    case IVL_ST_ASSIGN:
      if ( level != 0 ){
        WARNING("Blocking statements not supported \t\t\tLine: %d\tFile: %s\n",ivl_stmt_lineno(net),ivl_stmt_file(net));
        INFO("*** Treating blocking assignment as non-blocking assignment ***\n");
      }else{
        WARNING("Assign Initial Condition statement not supported\tLine: %d\tFile: %s\n",ivl_stmt_lineno(net),ivl_stmt_file(net));
        break;
      }
    case IVL_ST_ASSIGN_NB:
      DEBUG0("Non-blocking assign statement\n");
      break;
    case IVL_ST_BLOCK:
      DEBUG0("Block of some sort\n");
      break;
    case IVL_ST_WAIT:
      DEBUG0("Probably an @ process \n");
      process_statements(ivl_stmt_sub_stmt(net),++level);
      break;
    case IVL_ST_CASE:
      DEBUG0("Case statement\n");
      break;
    default:
      WARNING("Unsupported statement \t Line: %d \t File: %s \t (Error: %d)\n",ivl_stmt_lineno(net), ivl_stmt_file(net), ivl_statement_type(net));
  }
  return 0;
}

int show_constants(ivl_design_t des){
  /*
  unsigned i;

  for(i=0;i<ivl_design_consts(des);i++){
    ivl_net_const_t net= ivl_design_const(des,i);
    //ivl_variable_type_t var_type = ivl_const_type(net);
    DEBUG0("%d\tDesign Constant type \n",i);
  }
  */
  return 0;
}


